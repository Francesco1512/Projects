# -*- coding: utf-8 -*-
"""Merton model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DfGvbWpkJoHOSZ6YfPlThNYbSbPPphLH
"""

import os
import pandas as pd
import re
import matplotlib.pyplot as plt

# Spécifiez le chemin du dossier contenant les fichiers CSV
folder_path = '/content/drive/MyDrive/Colab Notebooks/EUTL/eutl_parsed_052023'

# Créer un dictionnaire pour stocker les DataFrames
dataframes = {}

# Parcourir tous les fichiers dans le dossier
for filename in os.listdir(folder_path):
    if filename.endswith('.csv'):
        # Construire le chemin complet vers le fichier
        file_path = os.path.join(folder_path, filename)

        # Lire le fichier CSV dans un DataFrame
        df = pd.read_csv(file_path)

        # Utiliser le nom du fichier (sans l'extension) comme clé du dictionnaire
        dataframe_name = os.path.splitext(filename)[0]

        # Ajouter le DataFrame au dictionnaire
        dataframes[dataframe_name] = df

# Loading data for each year
data_dict = {}
for year in range(2012, 2025):
    if year <= 2019:
        file_path = f'emission-spot-primary-market-auction-report-{year}-data.xls'
    else:
        file_path = f'emission-spot-primary-market-auction-report-{year}-data.xlsx'

    if year < 2017:
        data = pd.read_excel(file_path, header=2)
    else:
        data = pd.read_excel(file_path, header=5)

    data_dict[str(year)] = data

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

class MertonModel:
    def __init__(self, V, D, T, r, sigma):
        """
        Parameters:
        V (float): Value of the firm's assets.
        D (float): Face value of the firm's debt.
        T (float): Time to maturity of the debt.
        r (float): Risk-free interest rate.
        sigma (float): Volatility of the firm's assets.
        """
        self.V = V
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.sigma = sigma

    def d1(self):
        return (np.log(self.V / self.D) + (self.r + 0.5 * self.sigma ** 2) * (self.T-self.t)) / (self.sigma * np.sqrt(self.T))

    def d2(self):
        return self.d1() - self.sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self):
        """
        Calculate the value of the firm's equity using the Merton model.
        """
        d1 = self.d1()
        d2 = self.d2()
        equity_value = self.V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
        return equity_value

    def calculate_default_probability(self):
        """
        Calculate the risk-neutral probability of default.
        """
        d2 = self.d2()
        default_probability = norm.cdf(-d2)
        return default_probability

    def calculate_distance_to_default(self):
        """
        Calculate the distance to default.
        """
        d2 = self.d2()
        return d2

def objective_function(params, real_equity_value, D, T, r):
    V, sigma = params
    model = MertonModel(D, T, r)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Example usage
real_equity_value = 20
V = 100  # Value of the firm's assets
D = 80   # Face value of the firm's debt
T = 1    # Time to maturity (in years)
t = 0
r = 0.05  # Risk-free interest rate
sigma = 0.2  # Volatility of the firm's assets

merton_model = MertonModel(V, D, T, r, sigma)
initial_guess = [100, 0.2]
bounds = [(1e-5, None), (1e-5, 1)]
equity_value = merton_model.calculate_equity_value()
default_probability = merton_model.calculate_default_probability()
distance_to_default = merton_model.calculate_distance_to_default()
result = minimize(objective_function, initial_guess, args=(real_equity_value, D, T, r), bounds=bounds)
optimal_V, optimal_sigma = result.x

print(f"Optimal V: {optimal_V:.2f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")
print(f"Equity Value: {equity_value:.2f}")
print(f"Default Probability: {default_probability:.4f}")
print(f"Distance to Default: {distance_to_default:.4f}")

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

class MertonModel:
    def __init__(self, D, T, r, t):
        """
        Parameters:
        D (float): Face value of the firm's debt.
        T (float): Time to maturity of the debt.
        r (float): Risk-free interest rate.
        """
        self.D = D
        self.T = T
        self.t = t
        self.r = r

    def d1(self, V, sigma):
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T-self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, V, sigma):
        return self.d1(V, sigma) - sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self, V, sigma):
        """
        Calculate the value of the firm's equity using the Merton model.
        """
        d1 = self.d1(V, sigma)
        d2 = self.d2(V, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
        return equity_value

# Objective function to minimize
def objective_function(params, real_equity_value, D, T, t, r):
    V, sigma = params
    model = MertonModel(D, T, t, r)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Example usage
real_equity_value = 20  # Observed market value of the firm's equity
D = 80   # Face value of the firm's debt
T = 1    # Time to maturity (in years)
r = 0.05  # Risk-free interest rate
t = 0.3

initial_guess = [100, 0.2]
bounds = [(None, None), (None, None)]
# Minimize the objective function
result = minimize(objective_function, initial_guess, args=(real_equity_value, D, T, t, r), bounds=bounds)

optimal_V, optimal_sigma = result.x

print(f"Optimal V: {optimal_V:.2f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")

DD = (np.log(optimal_V / D) + (r + optimal_sigma ** 2 / 2)*(T - t))/(optimal_sigma * np.sqrt(T - t))
print(f"DD: {DD:.2f}")

result.fun

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

class MertonModel:
    def __init__(self, D, T, r, t, mu):
        """
        Parameters:
        D (float): Face value of the firm's debt.
        T (float): Time to maturity of the debt.
        r (float): Risk-free interest rate.
        """
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.mu = mu

    def d1(self, V, sigma):
        return (np.log(V / self.D) + (self.mu + 0.5 * sigma ** 2) * (self.T-self.t)) / (sigma * np.sqrt(self.T-self.t))

    def d2(self, V, sigma):
        return self.d1(V, sigma) - sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self, V, sigma):
        """
        Calculate the value of the firm's equity using the Merton model.
        """
        d1 = self.d1(V, sigma)
        d2 = self.d2(V, sigma)
        equity_value = V * np.exp((self.mu - self.r)*(self.T-self.t)) * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
        return equity_value
    def asset_value(alpha, book_value, beta):
      alpha = self.alpha
      book_value = self.book_value
      beta = self.beta
      return self.alpha * self.book_value + beta

# Objective function to minimize
def objective_function(params, real_equity_value, D, T, t, r):
    V, sigma, mu = params
    model = MertonModel(D, T, t, r, mu)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Example usage
real_equity_value = 20  # Observed market value of the firm's equity
D = 50   # Face value of the firm's debt
T = 1    # Time to maturity (in years)
r = 0.2  # Risk-free interest rate
t = 0

initial_guess = [100, 0.2, 0.1]
bounds = [(None, None), (None, None), (None, None)]
# Minimize the objective function
result = minimize(objective_function, initial_guess, args=(real_equity_value, D, T, t, r), bounds=bounds)

optimal_V, optimal_sigma, optimal_mu = result.x

print(f"Optimal V: {optimal_V:.2f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")
print(f"Optimal mu: {optimal_mu:.2f}")

DD = (np.log(optimal_V / D) + (r + optimal_sigma ** 2 / 2)*(T - t))/(optimal_sigma * np.sqrt(T - t))
print(f"DD: {DD:.2f}")

result.fun

import pandas as pd

# Load data from the Excel files
file1_path = 'BASF.xlsx'
file2_path = 'BASF_BS.xlsx'
file3_path = 'BASF SE.xlsx'

# Read the Excel files
df1 = pd.read_excel(file1_path)
df2 = pd.read_excel(file2_path)
df3 = pd.read_excel(file3_path)

# Display the first few rows of each dataframe to understand their structure
df1_head = df1.head()
df2_head = df2.head()
df3_head = df3.head()

df1_head, df2_head, df3_head

# Display the first few rows of each dataframe to understand their structure more clearly
df1_cleaned = df1.dropna(how='all').reset_index(drop=True)
df2_cleaned = df2.dropna(how='all').reset_index(drop=True)
df3_cleaned = df3.dropna(how='all').reset_index(drop=True)

df1_cleaned_head = df1_cleaned.head(10)
df2_cleaned_head = df2_cleaned.head(10)
df3_cleaned_head = df3_cleaned.head(10)

df1_cleaned_head, df2_cleaned_head, df3_cleaned_head

# Inspect the headers of each dataframe
df1_headers = df1_cleaned.columns
df2_headers = df2_cleaned.columns
df3_headers = df3_cleaned.columns

df1_headers, df2_headers, df3_headers

import pandas as pd
import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

# Function to extract financial variables from the dataframe
def extract_financial_variables(df, variable_name):
    # Drop completely empty rows and columns, reset index
    df = df.dropna(how='all').reset_index(drop=True)

    # Find the row where the variable_name is located
    variable_row = df[df.iloc[:, 0].str.contains(variable_name, na=False)]

    if variable_row.empty:
        return np.array([])

    # Extract the values starting from the column right after the variable name
    variable_values = variable_row.iloc[0, 1:].dropna().values.astype(float)

    return variable_values

# Extract financial variables from each dataframe
def extract_all_variables(df):
    debt = extract_financial_variables(df, 'Debt')
    equity = extract_financial_variables(df, 'Equity')
    r = extract_financial_variables(df, 'Risk-Free Rate')
    T = extract_financial_variables(df, 'Time to Maturity')
    return debt, equity, r, T

# Process each dataframe
debt1, equity1, r1, T1 = extract_all_variables(df1_cleaned)
debt2, equity2, r2, T2 = extract_all_variables(df2_cleaned)
debt3, equity3, r3, T3 = extract_all_variables(df3_cleaned)

# Combine all extracted variables
debt = np.concatenate((debt1, debt2, debt3))
equity = np.concatenate((equity1, equity2, equity3))
risk_free_rate = np.concatenate((r1, r2, r3))
time_to_maturity = np.concatenate((T1, T2, T3))

# Ensure all arrays have the same length for annual calculations
length = min(len(debt), len(equity), len(risk_free_rate), len(time_to_maturity))
debt = debt[:length]
equity = equity[:length]
risk_free_rate = risk_free_rate[:length]
time_to_maturity = time_to_maturity[:length]

# Initialize the sum of the objective function values
objective_sum = 0

# Define the Merton model and objective function
class MertonModel:
    def __init__(self, D, T, r, t, mu):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.mu = mu

    def d1(self, V, sigma):
        return (np.log(V / self.D) + (self.mu + 0.5 * sigma ** 2) * (self.T-self.t)) / (sigma * np.sqrt(self.T-self.t))

    def d2(self, V, sigma):
        return self.d1(V, sigma) - sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self, V, sigma):
        d1 = self.d1(V, sigma)
        d2 = self.d2(V, sigma)
        equity_value = V * np.exp((self.mu - self.r)*(self.T-self.t)) * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
        return equity_value

# Objective function to minimize
def objective_function(params, real_equity_value, D, T, t, r):
    V, sigma, mu = params
    model = MertonModel(D, T, t, r, mu)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Example usage
initial_guess = [100, 0.2, 0.1]
bounds = [(None, None), (None, None), (None, None)]

# Loop through the annual values and sum the objective function
for i in range(length):
    result = minimize(objective_function, initial_guess, args=(equity[i], debt[i], time_to_maturity[i], 0, risk_free_rate[i]), bounds=bounds)
    optimal_V, optimal_sigma, optimal_mu = result.x
    objective_sum += objective_function(result.x, equity[i], debt[i], time_to_maturity[i], 0, risk_free_rate[i])

print(f"Sum of objective function values: {objective_sum:.2f}")

import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import minimize

# Function to extract financial variables from the dataframe
def extract_financial_variables(df, variable_name):
    # Drop completely empty rows and columns, reset index
    df = df.dropna(how='all').reset_index(drop=True)

    # Find the row where the variable_name is located
    variable_row = df[df.iloc[:, 0].str.contains(variable_name, na=False)]

    if variable_row.empty:
        return np.array([])

    # Extract the values starting from the column right after the variable name
    variable_values = variable_row.iloc[0, 1:].dropna().values.astype(float)

    return variable_values

# Load the Excel files
df1 = pd.read_excel('BASF.xlsx')
df2 = pd.read_excel('BASF_BS.xlsx')
df3 = pd.read_excel('BASF SE.xlsx')

# Function to clean dataframes (assuming 'Unnamed' columns need to be renamed or dropped)
def clean_dataframe(df):
    df.columns = [str(col) for col in df.columns]
    return df

# Clean dataframes
df1_cleaned = clean_dataframe(df1)
df2_cleaned = clean_dataframe(df2)
df3_cleaned = clean_dataframe(df3)

# Extract financial variables from each dataframe
def extract_all_variables(df):
    debt = extract_financial_variables(df, 'Debt')
    equity = extract_financial_variables(df, 'Equity')
    r = extract_financial_variables(df, 'Risk-Free Rate')
    T = extract_financial_variables(df, 'Time to Maturity')
    return debt, equity, r, T

# Process each dataframe
debt1, equity1, r1, T1 = extract_all_variables(df1_cleaned)
debt2, equity2, r2, T2 = extract_all_variables(df2_cleaned)
debt3, equity3, r3, T3 = extract_all_variables(df3_cleaned)

# Combine all extracted variables
debt = np.concatenate((debt1, debt2, debt3))
equity = np.concatenate((equity1, equity2, equity3))
risk_free_rate = np.concatenate((r1, r2, r3))
time_to_maturity = np.concatenate((T1, T2, T3))

# Ensure all arrays have the same length for annual calculations
length = min(len(debt), len(equity), len(risk_free_rate), len(time_to_maturity))
debt = debt[:length]
equity = equity[:length]
risk_free_rate = risk_free_rate[:length]
time_to_maturity = time_to_maturity[:length]

# Define the Merton model and objective function
class MertonModel:
    def __init__(self, D, T, r, t, mu):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.mu = mu

    def d1(self, V, sigma):
        return (np.log(V / self.D) + (self.mu + 0.5 * sigma ** 2) * (self.T-self.t)) / (sigma * np.sqrt(self.T-self.t))

    def d2(self, V, sigma):
        return self.d1(V, sigma) - sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self, V, sigma):
        d1 = self.d1(V, sigma)
        d2 = self.d2(V, sigma)
        equity_value = V * np.exp((self.mu - self.r)*(self.T-self.t)) * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
        return equity_value

# Objective function to minimize
def objective_function(params, real_equity_value, D, T, t, r):
    V, sigma, mu = params
    model = MertonModel(D, T, t, r, mu)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Example usage
initial_guess = [100, 0.2, 0.1]
bounds = [(None, None), (None, None), (None, None)]

# Initialize the sum of the objective function values
objective_sum = 0

# Loop through the annual values and sum the objective function
for i in range(length):
    result = minimize(objective_function, initial_guess, args=(equity[i], debt[i], time_to_maturity[i], 0, risk_free_rate[i]), bounds=bounds)
    optimal_V, optimal_sigma, optimal_mu = result.x
    objective_sum += objective_function(result.x, equity[i], debt[i], time_to_maturity[i], 0, risk_free_rate[i])

print(f"Sum of objective function values: {objective_sum:.2f}")

# Optimal parameters for the last year in the loop
print(f"Optimal V: {optimal_V:.2f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")
print(f"Optimal mu: {optimal_mu:.2f}")

DD = (np.log(optimal_V / debt[-1]) + (risk_free_rate[-1] + optimal_sigma ** 2 / 2)*(time_to_maturity[-1] - 0)) / (optimal_sigma * np.sqrt(time_to_maturity[-1] - 0))
print(f"DD: {DD:.2f}")

import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import minimize

# Function to extract financial variables from the dataframe
def extract_financial_variables(df, variable_name):
    # Drop completely empty rows and columns, reset index
    df = df.dropna(how='all').reset_index(drop=True)

    # Print the DataFrame to debug
    print(f"DataFrame head:\n{df.head(10)}\n")

    # Find the row where the variable_name is located
    variable_row = df[df.iloc[:, 0].str.contains(variable_name, na=False)]

    if variable_row.empty:
        print(f"Variable '{variable_name}' not found.")
        return np.array([])

    # Print the found row to debug
    print(f"Found row for '{variable_name}':\n{variable_row}\n")

    # Extract the values starting from the column right after the variable name
    variable_values = variable_row.iloc[0, 1:].dropna().values.astype(float)

    return variable_values

# Load the Excel files
df1 = pd.read_excel('BASF.xlsx')
df2 = pd.read_excel('BASF_BS.xlsx')
df3 = pd.read_excel('BASF SE.xlsx')

# Function to clean dataframes (assuming 'Unnamed' columns need to be renamed or dropped)
def clean_dataframe(df):
    df.columns = [str(col) for col in df.columns]
    return df

# Clean dataframes
df1_cleaned = clean_dataframe(df1)
df2_cleaned = clean_dataframe(df2)
df3_cleaned = clean_dataframe(df3)

# Extract financial variables from each dataframe
def extract_all_variables(df):
    debt = extract_financial_variables(df, 'Debt')
    equity = extract_financial_variables(df, 'Equity')
    r = extract_financial_variables(df, 'Risk-Free Rate')
    T = extract_financial_variables(df, 'Time to Maturity')
    return debt, equity, r, T

# Process each dataframe
debt1, equity1, r1, T1 = extract_all_variables(df1_cleaned)
debt2, equity2, r2, T2 = extract_all_variables(df2_cleaned)
debt3, equity3, r3, T3 = extract_all_variables(df3_cleaned)

# Combine all extracted variables
debt = np.concatenate((debt1, debt2, debt3))
equity = np.concatenate((equity1, equity2, equity3))
risk_free_rate = np.concatenate((r1, r2, r3))
time_to_maturity = np.concatenate((T1, T2, T3))

# Print lengths of combined arrays
print(f"Length of debt array: {len(debt)}")
print(f"Length of equity array: {len(equity)}")
print(f"Length of risk-free rate array: {len(risk_free_rate)}")
print(f"Length of time to maturity array: {len(time_to_maturity)}")

# Ensure all arrays have the same length for annual calculations
length = min(len(debt), len(equity), len(risk_free_rate), len(time_to_maturity))
debt = debt[:length]
equity = equity[:length]
risk_free_rate = risk_free_rate[:length]
time_to_maturity = time_to_maturity[:length]

# Print contents of the arrays to debug
print("Debt array:", debt)
print("Equity array:", equity)
print("Risk-free rate array:", risk_free_rate)
print("Time to maturity array:", time_to_maturity)

# Define the Merton model and objective function
class MertonModel:
    def __init__(self, D, T, r, t, mu):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.mu = mu

    def d1(self, V, sigma):
        return (np.log(V / self.D) + (self.mu + 0.5 * sigma ** 2) * (self.T-self.t)) / (sigma * np.sqrt(self.T-self.t))

    def d2(self, V, sigma):
        return self.d1(V, sigma) - sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self, V, sigma):
        d1 = self.d1(V, sigma)
        d2 = self.d2(V, sigma)
        equity_value = V * np.exp((self.mu - self.r)*(self.T-self.t)) * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
        return equity_value

# Objective function to minimize
def objective_function(params, real_equity_value, D, T, t, r):
    V, sigma, mu = params
    model = MertonModel(D, T, t, r, mu)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Example usage
initial_guess = [100, 0.2, 0.1]
bounds = [(None, None), (None, None), (None, None)]

# Initialize the sum of the objective function values
objective_sum = 0

# Loop through the annual values and sum the objective function
for i in range(length):
    result = minimize(objective_function, initial_guess, args=(equity[i], debt[i], time_to_maturity[i], 0, risk_free_rate[i]), bounds=bounds)
    optimal_V, optimal_sigma, optimal_mu = result.x
    objective_sum += objective_function(result.x, equity[i], debt[i], time_to_maturity[i], 0, risk_free_rate[i])

print(f"Sum of objective function values: {objective_sum:.2f}")

# Optimal parameters for the last year in the loop
print(f"Optimal V: {optimal_V:.2f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")
print(f"Optimal mu: {optimal_mu:.2f}")

if len(debt) > 0 and len(risk_free_rate) > 0 and len(time_to_maturity) > 0:
    DD = (np.log(optimal_V / debt[-1]) + (risk_free_rate[-1] + optimal_sigma ** 2 / 2)*(time_to_maturity[-1] - 0)) / (optimal_sigma * np.sqrt(time_to_maturity[-1] - 0))
    print(f"DD: {DD:.2f}")
else:
    print("Error: One of the arrays is empty, cannot calculate DD")



import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import minimize

# Function to extract financial variables from the dataframe
def extract_financial_variables(df, variable_name):
    # Drop completely empty rows and columns, reset index
    df = df.dropna(how='all').reset_index(drop=True)

    # Print the DataFrame to debug
    print(f"DataFrame head:\n{df.head(10)}\n")

    # Print all column headers
    print(f"Column headers: {list(df.columns)}\n")

    # Find the row where the variable_name is located
    variable_row = df[df.iloc[:, 0].str.contains(variable_name, na=False, case=False)]

    if variable_row.empty:
        print(f"Variable '{variable_name}' not found.")
        print(f"Here are the first 10 rows to debug:\n{df.head(10)}\n")
        return np.array([])

    # Print the found row to debug
    print(f"Found row for '{variable_name}':\n{variable_row}\n")

    # Extract the values starting from the column right after the variable name
    variable_values = variable_row.iloc[0, 1:].dropna().values.astype(float)

    return variable_values

# Load the Excel files
df1 = pd.read_excel('BASF SE.xlsx')
df2 = pd.read_excel('BASF.xlsx')
df3 = pd.read_excel('BASF.xlsx')

# Function to clean dataframes (assuming 'Unnamed' columns need to be renamed or dropped)
def clean_dataframe(df):
    df.columns = [str(col) for col in df.columns]
    return df

# Clean dataframes
df1_cleaned = clean_dataframe(df1)
df2_cleaned = clean_dataframe(df2)
df3_cleaned = clean_dataframe(df3)

# Extract financial variables from each dataframe
def extract_all_variables(df):
    debt = extract_financial_variables(df, 'Debt')
    equity = extract_financial_variables(df, 'Equity')
    r = extract_financial_variables(df, 'Risk-Free Rate')
    T = extract_financial_variables(df, 'Time to Maturity')
    return debt, equity, r, T

# Process each dataframe
debt1, equity1, r1, T1 = extract_all_variables(df1_cleaned)
debt2, equity2, r2, T2 = extract_all_variables(df2_cleaned)
debt3, equity3, r3, T3 = extract_all_variables(df3_cleaned)

# Combine all extracted variables
debt = np.concatenate((debt1, debt2, debt3))
equity = np.concatenate((equity1, equity2, equity3))
risk_free_rate = np.concatenate((r1, r2, r3))
time_to_maturity = np.concatenate((T1, T2, T3))

# Print lengths of combined arrays
print(f"Length of debt array: {len(debt)}")
print(f"Length of equity array: {len(equity)}")
print(f"Length of risk-free rate array: {len(risk_free_rate)}")
print(f"Length of time to maturity array: {len(time_to_maturity)}")

# Ensure all arrays have the same length for annual calculations
length = min(len(debt), len(equity), len(risk_free_rate), len(time_to_maturity))
debt = debt[:length]
equity = equity[:length]
risk_free_rate = risk_free_rate[:length]
time_to_maturity = time_to_maturity[:length]

# Print contents of the arrays to debug
print("Debt array:", debt)
print("Equity array:", equity)
print("Risk-free rate array:", risk_free_rate)
print("Time to maturity array:", time_to_maturity)

# Define the Merton model and objective function
class MertonModel:
    def __init__(self, D, T, r, t, mu):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.mu = mu

    def d1(self, V, sigma):
        return (np.log(V / self.D) + (self.mu + 0.5 * sigma ** 2) * (self.T-self.t)) / (sigma * np.sqrt(self.T-self.t))

    def d2(self, V, sigma):
        return self.d1(V, sigma) - sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self, V, sigma):
        d1 = self.d1(V, sigma)
        d2 = self.d2(V, sigma)
        equity_value = V * np.exp((self.mu - self.r)*(self.T-self.t)) * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
        return equity_value

# Objective function to minimize
def objective_function(params, real_equity_value, D, T, t, r):
    V, sigma, mu = params
    model = MertonModel(D, T, t, r, mu)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Example usage
initial_guess = [100, 0.2, 0.1]
bounds = [(None, None), (None, None), (None, None)]

# Initialize the sum of the objective function values
objective_sum = 0

# Loop through the annual values and sum the objective function
for i in range(length):
    result = minimize(objective_function, initial_guess, args=(equity[i], debt[i], time_to_maturity[i], 0, risk_free_rate[i]), bounds=bounds)
    optimal_V, optimal_sigma, optimal_mu = result.x
    objective_sum += objective_function(result.x, equity[i], debt[i], time_to_maturity[i], 0, risk_free_rate[i])

print(f"Sum of objective function values: {objective_sum:.2f}")

# Optimal parameters for the last year in the loop
print(f"Optimal V: {optimal_V:.2f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")
print(f"Optimal mu: {optimal_mu:.2f}")

if len(debt) > 0 and len(risk_free_rate) > 0 and len(time_to_maturity) > 0:
    DD = (np.log(optimal_V / debt[-1]) + (risk_free_rate[-1] + optimal_sigma ** 2 / 2)*(time_to_maturity[-1] - 0)) / (optimal_sigma * np.sqrt(time_to_maturity[-1] - 0))
    print(f"DD: {DD:.2f}")
else:
    print("Error: One of the arrays is empty, cannot calculate DD")

import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import minimize

# Function to extract financial variables from the dataframe
def extract_financial_variables(df, variable_name):
    # Drop completely empty rows and columns, reset index
    df = df.dropna(how='all').reset_index(drop=True)

    # Print the DataFrame to debug
    print(f"DataFrame head:\n{df.head(10)}\n")

    # Print all column headers
    print(f"Column headers: {list(df.columns)}\n")

    # Find the row where the variable_name is located
    variable_row = df[df.iloc[:, 0].str.contains(variable_name, na=False, case=False)]

    if variable_row.empty:
        print(f"Variable '{variable_name}' not found.")
        print(f"Here are the first 10 rows to debug:\n{df.head(10)}\n")
        return np.array([])

    # Print the found row to debug
    print(f"Found row for '{variable_name}':\n{variable_row}\n")

    # Extract the values starting from the column right after the variable name
    variable_values = variable_row.iloc[0, 1:].dropna().values.astype(float)

    return variable_values

# Load the Excel files
df1 = pd.read_excel('BASF.xlsx')
df2 = pd.read_excel('BASF_BS.xlsx')
df3 = pd.read_excel('BASF SE.xlsx')

# Function to clean dataframes (assuming 'Unnamed' columns need to be renamed or dropped)
def clean_dataframe(df):
    df.columns = [str(col) for col in df.columns]
    return df

# Clean dataframes
df1_cleaned = clean_dataframe(df1)
df2_cleaned = clean_dataframe(df2)
df3_cleaned = clean_dataframe(df3)

# Extract financial variables from each dataframe
def extract_all_variables(df):
    debt = extract_financial_variables(df, 'Debt')
    return debt

# Process each dataframe
debt1 = extract_all_variables(df1_cleaned)
debt2 = extract_all_variables(df2_cleaned)
debt3 = extract_all_variables(df3_cleaned)

# Combine all extracted variables
debt = np.concatenate((debt1, debt2, debt3))

# Print lengths of combined arrays
print(f"Length of debt array: {len(debt)}")

# Ensure all arrays have the same length for annual calculations
length = len(debt)
debt = debt[:length]

# Print contents of the arrays to debug
print("Debt array:", debt)

# Define the Merton model and objective function
class MertonModel:
    def __init__(self, D, T, r, t, mu):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.mu = mu

    def d1(self, V, sigma):
      V = asset_value(alpha, book_value, beta)
        return (np.log(V / self.D) + (self.mu + 0.5 * sigma ** 2) * (self.T-self.t)) / (sigma * np.sqrt(self.T-self.t))

    def d2(self, V, sigma):
      V = asset_value(alpha, book_value, beta)
        return self.d1(V, sigma) - sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self, V, sigma):
      V = asset_value(alpha, book_value, beta)
        d1 = self.d1(V, sigma)
        d2 = self.d2(V, sigma)
        equity_value = V * np.exp((self.mu - self.r)*(self.T-self.t)) * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
        return equity_value
    def asset_value(alpha, book_value, beta):
      alpha = self.alpha
      book_value = self.book_value
      beta = self.beta
      return self.alpha * self.book_value + beta


# Objective function to minimize
def objective_function(params, real_equity_value, D, T, t, r):
    V, sigma, mu = params
    model = MertonModel(D, T, t, r, mu)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Constants
risk_free_rate = 0.1
time_to_maturity = 1

# Example usage
initial_guess = [100, 0.2, 0.1]
bounds = [(None, None), (None, None), (None, None)]

# Initialize the sum of the objective function values
objective_sum = 0

# Loop through the annual values and sum the objective function
for i in range(length):
    result = minimize(objective_function, initial_guess, args=(equity[i], debt[i], time_to_maturity, 0, risk_free_rate), bounds=bounds)
    optimal_V, optimal_sigma, optimal_mu = result.x
    objective_sum += objective_function(result.x, equity[i], debt[i], time_to_maturity, 0, risk_free_rate)

print(f"Sum of objective function values: {objective_sum:.2f}")

# Optimal parameters for the last year in the loop
print(f"Optimal V: {optimal_V:.2f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")
print(f"Optimal mu: {optimal_mu:.2f}")

if len(debt) > 0:
    DD = (np.log(optimal_V / debt[-1]) + (risk_free_rate + optimal_sigma ** 2 / 2)*(time_to_maturity - 0)) / (optimal_sigma * np.sqrt(time_to_maturity - 0))
    print(f"DD: {DD:.2f}")
else:

    print("Error: The debt array is empty, cannot calculate DD")

class MertonModel:
    def __init__(self, D, T, r, t):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
    def asset_value(alpha, book_value, beta):
      alpha = self.alpha
      book_value = self.book_value
      beta = self.beta
      return self.alpha * self.book_value + beta

    def d1(self, V, sigma):
      V = asset_value(alpha, book_value, beta)
      return (np.log(V / self.D) + (self.mu + 0.5 * sigma ** 2) * (self.T-self.t)) / (sigma * np.sqrt(self.T-self.t))

    def d2(self, V, sigma):
      V = asset_value(alpha, book_value, beta)
      return self.d1(V, sigma) - sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self, V, sigma):
      V = asset_value(alpha, book_value, beta)
      d1 = self.d1(V, sigma)
      d2 = self.d2(V, sigma)
      equity_value = V * np.exp((self.mu - self.r)*(self.T-self.t)) * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
      return equity_value

def objective_function(params, real_equity_value, D, T, t, r):
    V, sigma = params
    model = MertonModel(D, T, t, r)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Example usage
real_equity_value = 20  # Observed market value of the firm's equity
D = 80   # Face value of the firm's debt
T = 1    # Time to maturity (in years)
r = 0.05  # Risk-free interest rate
t = 0.3

initial_guess = [0.1, 0.1, 0.1]
bounds = [(None, None), (None, None), (None, None)]
# Minimize the objective function
result = minimize(objective_function, initial_guess, args=(real_equity_value, D, T, t, r), bounds=bounds)

optimal_alpha, optimal_beta, optimal_sigma = result.x

print(f"Optimal alpha: {optimal_alpha:.4f}")
print(f"Optimal beta: {optimal_beta:.4f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

class MertonModel:
    def __init__(self, D, T, r, t):
        """
        Parameters:
        D (float): Face value of the firm's debt.
        T (float): Time to maturity of the debt.
        r (float): Risk-free interest rate.
        """
        self.D = D
        self.T = T
        self.t = t
        self.r = r

    def d1(self, V, sigma):
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T-self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, V, sigma):
        return self.d1(V, sigma) - sigma * np.sqrt(self.T-self.t)

    def calculate_equity_value(self, V, sigma):
        """
        Calculate the value of the firm's equity using the Merton model.
        """
        d1 = self.d1(V, sigma)
        d2 = self.d2(V, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T-self.t)) * norm.cdf(d2)
        return equity_value

# Objective function to minimize
def objective_function(params, real_equity_value, D, T, t, r):
    V, sigma = params
    model = MertonModel(D, T, t, r)
    calculated_equity_value = model.calculate_equity_value(V, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Example usage
real_equity_value = 20  # Observed market value of the firm's equity
D = 80   # Face value of the firm's debt
T = 1    # Time to maturity (in years)
r = 0.05  # Risk-free interest rate
t = 0.3

initial_guess = [100, 0.2]
bounds = [(None, None), (None, None)]
# Minimize the objective function
result = minimize(objective_function, initial_guess, args=(real_equity_value, D, T, t, r), bounds=bounds)

optimal_V, optimal_sigma = result.x

print(f"Optimal V: {optimal_V:.2f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")

DD = (np.log(optimal_V / D) + (r + optimal_sigma ** 2 / 2)*(T - t))/(optimal_sigma * np.sqrt(T - t))
print(f"DD: {DD:.2f}")

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

class Model:
    def __init__(self, D, T, r, t):
        self.D = D
        self.T = T
        self.t = t
        self.r = r

    def asset_value(self, alpha, beta):
        return alpha * self.D + beta

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        d1 = self.d1(alpha, beta, sigma)
        return d1 - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * np.exp((self.r - self.r) * (self.T - self.t)) * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, real_equity_value, D, T, t, r):
    alpha, beta, sigma = params
    model = Model(D, T, r, t)
    calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

real_equity_value = 20
D = 50
T = 1
r = 0.25
t = 0.3

initial_guess = [0.001, 0.001, 0.001]
bounds = [(None, None), (None, None), (None, None)]

result = minimize(objective_function, initial_guess, args=(real_equity_value, D, T, t, r), bounds=bounds)
optimal_alpha, optimal_beta, optimal_sigma = result.x

print(f"Optimal alpha: {optimal_alpha:.4f}")
print(f"Optimal beta: {optimal_beta:.4f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

class Model:
    def __init__(self, D, T, r, t):
        self.D = D
        self.T = T
        self.t = t
        self.r = r

    def asset_value(self, alpha, beta):
        return alpha * self.Vb + beta

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        d1 = self.d1(alpha, beta, sigma)
        return d1 - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, real_equity_value, D, T, t, r):
    alpha, beta, sigma = params
    model = Model(D, T, r, t)
    calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
    return (real_equity_value - calculated_equity_value) ** 2

# Given values
real_equity_value = 20
D = 50
T = 1
r = 0.25
t = 0.3

# Different initial guesses to check for robustness
initial_guesses = [
    [0.1, 0.1, 0.1],
    [0.2, 0.2, 0.2],
    [0.5, 0.5, 0.5],
    [1.0, 1.0, 1.0],
    [1.5, 1.5, 1.5]
]

for initial_guess in initial_guesses:
    result = minimize(objective_function, initial_guess, args=(real_equity_value, D, T, t, r), bounds=[(0, None), (0, None), (0, None)])
    optimal_alpha, optimal_beta, optimal_sigma = result.x

    print(f"Initial guess: {initial_guess}")
    print(f"Optimal alpha: {optimal_alpha:.4f}")
    print(f"Optimal beta: {optimal_beta:.4f}")
    print(f"Optimal sigma: {optimal_sigma:.4f}")
    print("-" * 50)

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize, differential_evolution

class Model:
    def __init__(self, D, T, r, t):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        return alpha * self.Vb + beta

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        d1 = self.d1(alpha, beta, sigma)
        return d1 - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value


def objective_function(params, real_equity_value, D, T, t, r):
    alpha, beta, sigma = params
    model = Model(D, T, r, t)
    calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
    return (real_equity_value - calculated_equity_value) ** 2



# Given values
real_equity_value = 20
Vb = 20
D = 50
T = 1
r = 0.25
t = 0.3


# Using differential evolution for global optimization
bounds = [(-5, 5), (-5, 5), (0, 150)]
result = differential_evolution(objective_function, bounds, args=(real_equity_value, D, T, t, r), disp=True)

optimal_alpha, optimal_beta, optimal_sigma = result.x

print(f"Optimal alpha: {optimal_alpha:.4f}")
print(f"Optimal beta: {optimal_beta:.4f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        return alpha * self.Vb + beta

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        d1 = self.d1(alpha, beta, sigma)
        return d1 - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value


def objective_function(params, real_equity_value, D, T, t, r, Vb):
    alpha, beta, sigma = params
    model = Model(D, T, r, t, Vb)
    calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
    return (real_equity_value - calculated_equity_value) ** 2


# Given values
real_equity_value = 100
Vb = 20
D = 50
T = 1
r = 0.25
t = 0.3

# Initial guess for alpha, beta, sigma
initial_guess = [1, 1, 1]

# Adding constraints to ensure V is positive
constraints = (
    {'type': 'ineq', 'fun': lambda params: params[0] * Vb + params[1]}  # alpha * Vb + beta > 0
)

# Using minimize for local optimization with constraints
result = minimize(objective_function, initial_guess, args=(real_equity_value, D, T, t, r, Vb), method='SLSQP', constraints=constraints)

optimal_alpha, optimal_beta, optimal_sigma = result.x

print(f"Optimal alpha: {optimal_alpha:.4f}")
print(f"Optimal beta: {optimal_beta:.4f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb


    def asset_value(self, alpha, beta):
        return alpha * self.Vb + beta

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        d1 = self.d1(alpha, beta, sigma)
        return d1 - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value


def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0

    for _, row in df.iterrows():
        D = row['Book value total (debt)']
        Vb = row['Book value total (A)']
        r = row['risk free rate']
        T = row['T']
        real_equity_value = row['E']

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2

    return total_error

# Load data
file_path = 'mercedes.xlsx'
df = pd.read_excel(file_path)

# Initial guess for alpha, beta, sigma
initial_guess = [1, 1, 1]

# Adding constraints to ensure V is positive
constraints = (
    {'type': 'ineq', 'fun': lambda params: params[0] * df['Book value total (A)'] + params[1]}  # alpha * Vb + beta > 0
)

# Using minimize for local optimization with constraints
result = minimize(objective_function, initial_guess, args=(df,), method='SLSQP', constraints=constraints)

optimal_alpha, optimal_beta, optimal_sigma = result.x

print(f"Optimal alpha: {optimal_alpha:.4f}")
print(f"Optimal beta: {optimal_beta:.4f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        return alpha * self.Vb + beta

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        d1 = self.d1(alpha, beta, sigma)
        return d1 - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0

    for _, row in df.iterrows():
        D = row['Book value total (debt)']
        Vb = row['Book value total (A)']
        r = row['risk free rate']
        T = row['T']
        real_equity_value = row['E']

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2

    return total_error

# Load data
file_path = 'mercedes.xlsx'
df = pd.read_excel(file_path)

# Initial guess for alpha, beta, sigma
initial_guess = [0.5, 0.5, 0.5]

# Adding constraints to ensure V is positive for all data points
constraints = (
    {'type': 'ineq', 'fun': lambda params: params[0] * df['Book value total (A)'].min() + params[1] - 1e-5}  # Adding a small value to avoid zero
)

# Using minimize with trust-constr method for local optimization with constraints
result = minimize(objective_function, initial_guess, args=(df,), method='trust-constr', constraints=constraints)

optimal_alpha, optimal_beta, optimal_sigma = result.x

print(f"Optimal alpha: {optimal_alpha:.10f}")
print(f"Optimal beta: {optimal_beta:.4f}")
print(f"Optimal sigma: {optimal_sigma:.4f}")
result.fun

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize
import pandas as pd

class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        V = alpha * self.Vb + beta
        return max(V, 1e-5)  # Ensure V is positive

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        if V <= 0 or self.D <= 0:
            return np.nan  # Return NaN to handle invalid log computation
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        d1 = self.d1(alpha, beta, sigma)
        if np.isnan(d1):
            return np.nan  # Propagate NaN if d1 is NaN
        return d1 - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        if np.isnan(d1) or np.isnan(d2):
            return np.nan  # Propagate NaN if either d1 or d2 is NaN
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Book value total (debt)']
        Vb = row['Book value total (A)']
        r = row['risk free rate']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        if np.isnan(calculated_equity_value):
            continue  # Skip invalid calculations
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    # Adding regularization term to prevent trivial solutions
    regularization_term = 0.1 * (alpha**2 + beta**2 + sigma**2)
    total_error += regularization_term

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Load data
file_path = 'mercedes.xlsx'
df = pd.read_excel(file_path)

# Check for anomalies in data
print(df.describe())

# Initial guess for alpha, beta, sigma away from bounds
initial_guess = [0.5, 0.5, 0.5]

# Bounds for the parameters ensuring they stay positive
bounds = [(1e-5, None), (1e-5, None), (1e-5, None)]  # small positive values to avoid zero

# Using minimize with L-BFGS-B method for optimization with bounds
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B', bounds=bounds)

optimal_alpha, optimal_beta, optimal_sigma = result.x

print(f"Optimal alpha: {optimal_alpha:.6f}")
print(f"Optimal beta: {optimal_beta:.6f}")
print(f"Optimal sigma: {optimal_sigma:.6f}")
result.fun

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize
import pandas as pd
from sklearn.preprocessing import StandardScaler

# Load data from the provided Excel file
file_path = 'convivo.xlsx'
df = pd.read_excel(file_path)

# Normalize the relevant columns
scaler = StandardScaler()
df[['Total Liabilities', 'E', 'Total Assets']] = scaler.fit_transform(df[['Total Liabilities', 'E', 'Total Assets']])

# Define the Model and objective_function
class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        V = alpha * self.Vb + beta
        return max(V, 1e-5)  # Ensure V is positive

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        return self.d1(alpha, beta, sigma) - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Initial guess for alpha, beta, sigma
initial_guess = [0.5, 0.5, 0.5]

# Bounds for the parameters

# Using minimize with L-BFGS-B method for optimization with bounds
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B')

optimal_alpha, optimal_beta, optimal_sigma = result.x

print(f"Optimal alpha: {optimal_alpha:.6f}")
print(f"Optimal beta: {optimal_beta:.6f}")
print(f"Optimal sigma: {optimal_sigma:.6f}")
print(f"Objective function value: {result.fun}")

# Load data from the provided Excel file
file_path = 'convivo.xlsx'
df = pd.read_excel(file_path)

# Describe the data to check for any anomalies
print(df.describe())

# Check for any missing values
print(df.isnull().sum())

# Normalize the relevant columns again
scaler = StandardScaler()
df[['Total Liabilities', 'E', 'Total Assets']] = scaler.fit_transform(df[['Total Liabilities', 'E', 'Total Assets']])
def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    # Adjusting regularization term to a smaller value
    regularization_term = 0.01 * (alpha**2 + beta**2 + sigma**2)
    total_error += regularization_term

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Different initial guess for alpha, beta, sigma
initial_guess = [1.0, 1.0, 1.0]

# Bounds for the parameters ensuring they stay positive
bounds = [(1e-5, None), (1e-5, None), (1e-5, None)]  # small positive values to avoid zero

# Using minimize with L-BFGS-B method for optimization with bounds
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B', bounds=bounds)

optimal_alpha, optimal_beta, optimal_sigma = result.x

print(f"Optimal alpha: {optimal_alpha:.6f}")
print(f"Optimal beta: {optimal_beta:.6f}")
print(f"Optimal sigma: {optimal_sigma:.6f}")
print(f"Objective function value: {result.fun}")

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize
import pandas as pd
from sklearn.preprocessing import StandardScaler

# Load data from the provided Excel file
file_path = 'convivo.xlsx'
df = pd.read_excel(file_path)

# Normalize the relevant columns
scaler = StandardScaler()
df[['Total Liabilities', 'E', 'Total Assets']] = scaler.fit_transform(df[['Total Liabilities', 'E', 'Total Assets']])

# Define the Model and objective_function
class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        V = alpha * self.Vb + beta
        return max(V, 1e-5)  # Ensure V is positive

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        return self.d1(alpha, beta, sigma) - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Initial guess for alpha, beta, sigma
initial_guess = [0.5, 0.5, 0.5]

# Using minimize with L-BFGS-B method for optimization
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B')

optimal_alpha, optimal_beta, optimal_sigma = result.x

optimal_results = {
    "Optimal alpha": optimal_alpha,
    "Optimal beta": optimal_beta,
    "Optimal sigma": optimal_sigma,
    "Objective function value": result.fun
}

optimal_results

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize
import pandas as pd
from sklearn.preprocessing import StandardScaler

# Load data from the provided Excel file
file_path = 'convivo.xlsx'
df = pd.read_excel(file_path)

# Normalize the relevant columns
scaler = StandardScaler()
df[['Total Liabilities', 'E', 'Total Assets']] = scaler.fit_transform(df[['Total Liabilities', 'E', 'Total Assets']])

# Define the Model and objective_function
class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        V = alpha * self.Vb + beta
        return max(V, 1e-5)  # Ensure V is positive

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        return self.d1(alpha, beta, sigma) - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Initial guess for alpha, beta, sigma
initial_guess = [0.5, 0.5, 0.5]

# Using minimize with L-BFGS-B method for optimization
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B')

optimal_alpha, optimal_beta, optimal_sigma = result.x

optimal_results = {
    "Optimal alpha": optimal_alpha,
    "Optimal beta": optimal_beta,
    "Optimal sigma": optimal_sigma,
    "Objective function value": result.fun
}

optimal_results

from sklearn.preprocessing import MinMaxScaler

# Min-max normalization
scaler = MinMaxScaler()
df[['Total Liabilities', 'E', 'Total Assets']] = scaler.fit_transform(df[['Total Liabilities', 'E', 'Total Assets']])

# Re-define and run the optimization process
class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        V = alpha * self.Vb + beta
        return max(V, 1e-5)  # Ensure V is positive

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        return self.d1(alpha, beta, sigma) - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Initial guess for alpha, beta, sigma
initial_guess = [0.5, 0.5, 0.5]

# Using minimize with L-BFGS-B method for optimization
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B')

optimal_alpha, optimal_beta, optimal_sigma = result.x

optimal_results = {
    "Optimal alpha": optimal_alpha,
    "Optimal beta": optimal_beta,
    "Optimal sigma": optimal_sigma,
    "Objective function value": result.fun
}

optimal_results

# Calculate asset_value and DD for each period
def calculate_asset_and_dd(row, alpha, beta, sigma):
    D = row['Total Liabilities']
    Vb = row['Total Assets']
    r = row['r']
    T = row['T']
    t = 0  # Assuming t is 0 as we don't have a separate column for it

    model = Model(D, T, r, t, Vb)
    asset_value = model.asset_value(alpha, beta)
    DD = (np.log(asset_value / D) + (r + 0.5 * sigma ** 2) * (T - t)) / (sigma * np.sqrt(T - t))
    return asset_value, DD

# Apply the function to each row in the dataframe
df[['Asset Value', 'DD']] = df.apply(lambda row: calculate_asset_and_dd(row, optimal_alpha, optimal_beta, optimal_sigma), axis=1, result_type='expand')

# Display the dataframe with the new columns
print(df[['Total Liabilities', 'Total Assets', 'E', 'Asset Value', 'DD']])

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize
import pandas as pd
from sklearn.preprocessing import MinMaxScaler

# Load data from the provided Excel file
file_path = 'convivo.xlsx'
df = pd.read_excel(file_path)

# Min-max normalization
scaler = MinMaxScaler()
df[['Total Liabilities', 'E', 'Total Assets']] = scaler.fit_transform(df[['Total Liabilities', 'E', 'Total Assets']])

# Define the Model class
class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        V = alpha * self.Vb + beta
        return max(V, 1e-5)  # Ensure V is positive

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        return self.d1(alpha, beta, sigma) - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

# Define the objective function for optimization
def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Initial guess for alpha, beta, sigma
initial_guess = [0.5, 0.5, 0.5]

# Using minimize with L-BFGS-B method for optimization
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B', bounds = [(0.001, None), (0.001, None), (0.001, None)])

optimal_alpha, optimal_beta, optimal_sigma = result.x

optimal_results = {
    "Optimal alpha": optimal_alpha,
    "Optimal beta": optimal_beta,
    "Optimal sigma": optimal_sigma,
    "Objective function value": result.fun
}

print(optimal_results)

def calculate_asset_and_dd(row, alpha, beta, sigma, T_horizon):
    D = row['Total Liabilities']
    Vb = row['Total Assets']
    r = row['r']
    t = 0  # Assuming t is 0 as we don't have a separate column for it

    if sigma <= 0 or T_horizon - t <= 0:
        return np.nan  # Return NaN if sigma or T - t is non-positive

    model = Model(D, T_horizon, r, t, Vb)
    asset_value = model.asset_value(alpha, beta)

    if D <= 0 or asset_value <= 0:
        return np.nan  # Return NaN if D or asset_value is non-positive

    DD = (np.log(asset_value / D) + (r + 0.5 * sigma ** 2) * (T_horizon - t)) / (sigma * np.sqrt(T_horizon - t))
    return DD

# Apply the function to each row in the dataframe for different time horizons
df['DD_1_year'] = df.apply(lambda row: calculate_asset_and_dd(row, optimal_alpha, optimal_beta, optimal_sigma, 1), axis=1)
df['DD_5_years'] = df.apply(lambda row: calculate_asset_and_dd(row, optimal_alpha, optimal_beta, optimal_sigma, 5), axis=1)
df['DD_10_years'] = df.apply(lambda row: calculate_asset_and_dd(row, optimal_alpha, optimal_beta, optimal_sigma, 10), axis=1)

# Display the dataframe with the new columns
print(df[['Total Liabilities', 'Total Assets', 'E', 'DD_1_year', 'DD_5_years', 'DD_10_years']])

import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize
import pandas as pd
from sklearn.preprocessing import MinMaxScaler

# Load data from the provided Excel file
file_path = 'convivo.xlsx'
df = pd.read_excel(file_path)

# Min-max normalization
scaler = MinMaxScaler()
df[['Total Liabilities', 'E', 'Total Assets']] = scaler.fit_transform(df[['Total Liabilities', 'E', 'Total Assets']])

# Define the Model class
class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        V = alpha * self.Vb + beta
        return max(V, 1e-5)  # Ensure V is positive

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        return self.d1(alpha, beta, sigma) - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

# Define the objective function for optimization
def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Initial guess for alpha, beta, sigma
initial_guess = [0.5, 0.5, 0.5]

# Using minimize with L-BFGS-B method for optimization
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B')

optimal_alpha, optimal_beta, optimal_sigma = result.x

optimal_results = {
    "Optimal alpha": optimal_alpha,
    "Optimal beta": optimal_beta,
    "Optimal sigma": optimal_sigma,
    "Objective function value": result.fun
}

print(optimal_results)

# Calculate asset_value and DD for each period
def calculate_asset_and_dd(row, alpha, beta, sigma):
    D = row['Total Liabilities']
    Vb = row['Total Assets']
    r = row['r']
    T = row['T']
    t = 0  # Assuming t is 0 as we don't have a separate column for it

    if sigma <= 0 or T - t <= 0:
        return np.nan, np.nan  # Return NaN if sigma or T - t is non-positive

    model = Model(D, T, r, t, Vb)
    asset_value = model.asset_value(alpha, beta)

    if D <= 0 or asset_value <= 0:
        return np.nan, np.nan  # Return NaN if D or asset_value is non-positive

    DD = (np.log(asset_value / D) + (r + 0.5 * sigma ** 2) * (T - t)) / (sigma * np.sqrt(T - t))
    return asset_value, DD

# Apply the function to each row in the dataframe
df[['Asset Value', 'DD']] = df.apply(lambda row: calculate_asset_and_dd(row, optimal_alpha, optimal_beta, optimal_sigma), axis=1, result_type='expand')

# Display the dataframe with the new columns
print(df[['Total Liabilities', 'Total Assets', 'E', 'Asset Value', 'DD']])

import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import minimize
from sklearn.preprocessing import MinMaxScaler

# Load data
file_path = 'ENGIE.xlsx'
df = pd.read_excel(file_path)

# Min-max normalization
scaler = MinMaxScaler()
df[['Total Liabilities', 'E', 'Total Assets']] = scaler.fit_transform(df[['Total Liabilities', 'E', 'Total Assets']])

# Define the Model class and objective function
class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        V = alpha * self.Vb + beta
        return max(V, 1e-5)  # Ensure V is positive

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        return self.d1(alpha, beta, sigma) - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Initial guess for alpha, beta, sigma
initial_guess = [0.5, 0.5, 0.5]

# Using minimize with L-BFGS-B method for optimization
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B', bounds = [(0.001, None), (0.001, None), (0.001, None)])

optimal_alpha, optimal_beta, optimal_sigma = result.x

# Calculate DD values
T_horizons = [1, 5, 10]
DD_columns = {1: 'DD_1_year', 5: 'DD_5_years', 10: 'DD_10_years'}

for T in T_horizons:
    df[DD_columns[T]] = np.nan  # Initialize DD columns

    for index, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        t = 0  # Starting time
        model = Model(D, T, r, t, Vb)

        asset_value = model.asset_value(optimal_alpha, optimal_beta)
        if asset_value <= 0 or D <= 0:
            continue  # Skip invalid rows

        DD = (np.log(asset_value / D) + (r + 0.5 * optimal_sigma ** 2) * (T - t)) / (optimal_sigma * np.sqrt(T - t))
        df.at[index, DD_columns[T]] = DD

# Save or print results
print(f"Optimal alpha: {optimal_alpha:.6f}")
print(f"Optimal beta: {optimal_beta:.6f}")
print(f"Optimal sigma: {optimal_sigma:.6f}")
print(f"Objective function value: {result.fun}")

print(df[['Total Liabilities', 'Total Assets', 'E', 'DD_1_year', 'DD_5_years', 'DD_10_years']])

import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import minimize
from sklearn.preprocessing import MinMaxScaler

# Load data
file_path = 'hera.xlsx'
df = pd.read_excel(file_path)

# Min-max normalization
scaler = MinMaxScaler()
df[['Total Liabilities', 'E', 'Total Assets']] = scaler.fit_transform(df[['Total Liabilities', 'E', 'Total Assets']])

# Define the Model class and objective function
class Model:
    def __init__(self, D, T, r, t, Vb):
        self.D = D
        self.T = T
        self.t = t
        self.r = r
        self.Vb = Vb

    def asset_value(self, alpha, beta):
        V = alpha * self.Vb + beta
        return max(V, 1e-5)  # Ensure V is positive

    def d1(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        return (np.log(V / self.D) + (self.r + 0.5 * sigma ** 2) * (self.T - self.t)) / (sigma * np.sqrt(self.T - self.t))

    def d2(self, alpha, beta, sigma):
        return self.d1(alpha, beta, sigma) - sigma * np.sqrt(self.T - self.t)

    def calculate_equity_value(self, alpha, beta, sigma):
        V = self.asset_value(alpha, beta)
        d1 = self.d1(alpha, beta, sigma)
        d2 = self.d2(alpha, beta, sigma)
        equity_value = V * norm.cdf(d1) - self.D * np.exp(-self.r * (self.T - self.t)) * norm.cdf(d2)
        return equity_value

def objective_function(params, df):
    alpha, beta, sigma = params
    total_error = 0
    count = 0  # To keep track of valid data points

    for _, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        T = row['T']
        real_equity_value = row['E']  # Assuming this is the real equity value

        if D <= 0 or Vb <= 0:
            continue  # Skip invalid debt or book value

        model = Model(D, T, r, 0, Vb)  # Assuming t is 0 as we don't have a separate column for it
        calculated_equity_value = model.calculate_equity_value(alpha, beta, sigma)
        total_error += (real_equity_value - calculated_equity_value) ** 2
        count += 1

    return total_error / max(count, 1)  # Normalize by count to avoid division by zero

# Initial guess for alpha, beta, sigma
initial_guess = [0.5, 0.5, 0.5]

# Using minimize with L-BFGS-B method for optimization
result = minimize(objective_function, initial_guess, args=(df,), method='L-BFGS-B', bounds = [(0.001, None), (0.001, None), (0.001, None)])

optimal_alpha, optimal_beta, optimal_sigma = result.x

# Calculate DD values
T_horizons = [1, 5, 10]
DD_columns = {1: 'DD_1_year', 5: 'DD_5_years', 10: 'DD_10_years'}

for T in T_horizons:
    df[DD_columns[T]] = np.nan  # Initialize DD columns

    for index, row in df.iterrows():
        D = row['Total Liabilities']
        Vb = row['Total Assets']
        r = row['r']
        t = 0  # Starting time
        model = Model(D, T, r, t, Vb)

        asset_value = model.asset_value(optimal_alpha, optimal_beta)
        if asset_value <= 0 or D <= 0 or optimal_sigma <= 0:
            continue  # Skip invalid rows

        try:
            DD = (np.log(asset_value / D) + (r + 0.5 * optimal_sigma ** 2) * (T - t)) / (optimal_sigma * np.sqrt(T - t))
            df.at[index, DD_columns[T]] = DD
        except (ValueError, ZeroDivisionError) as e:
            df.at[index, DD_columns[T]] = np.nan  # Handle exceptions

# Save or print results
print(f"Optimal alpha: {optimal_alpha:.6f}")
print(f"Optimal beta: {optimal_beta:.6f}")
print(f"Optimal sigma: {optimal_sigma:.6f}")
print(f"Objective function value: {result.fun}")

print(df[['Total Liabilities', 'Total Assets', 'E', 'DD_1_year', 'DD_5_years', 'DD_10_years']])

